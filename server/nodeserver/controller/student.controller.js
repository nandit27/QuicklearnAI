const Statistic = require('../models/statistic.model');
const multer = require('multer');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const doubtSchema = require('../models/doubt.model');
const Tesseract = require("tesseract.js");
const axios = require("axios");
const { GoogleGenerativeAI } = require("@google/generative-ai");
const Teacher = require('../models/teacher.model');
const Doubt = require('../models/doubt.model');
const redis = require('../redis.connection');
const { ChatGroq } = require("@langchain/groq");
async function storestatics(req, res) {
    try {
        const userId = req.userId;
        const { pasturl, score, totalscore, topic } = req.body;

        if (!pasturl || score === undefined || totalscore === undefined || !topic) {
            return res.status(400).json({ error: 'Missing required fields' });
        }
        const newStatistic = new Statistic({
            pasturl,
            score,
            totalscore,
            topic,
            student: userId
        });
        await newStatistic.save();
        res.status(201).json({ message: 'Statistics saved successfully' });
    } catch (error) {
        console.error('Error saving statistics:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
}
async function getstatistics(req, res) {
    try {
        const userId = req.userId;
        const statistics = await Statistic.find({ student: userId });
        res.status(200).json(statistics);
    } catch (error) {
        console.error('Error fetching statistics:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
}


// Multer storage configuration
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        cb(null, 'uploads/');
    },
    filename: function (req, file, cb) {
        cb(null, Date.now() + '-' + file.originalname);
    }
});


const upload = multer({
    storage: storage,
    limits: {
        fileSize: 5 * 1024 * 1024
    },
    fileFilter: function (req, file, cb) {
        if (!file.originalname.match(/\.(jpg|jpeg|png)$/)) {
            return cb(new Error('Only image files are allowed!'), false);
        }
        cb(null, true);
    }
});


async function getCategoryFromGroq(text) {
    try {
        const llm = new ChatGroq({
            apiKey: process.env.GROQ_API_KEY,
            model: "llama3-8b-8192",
            temperature: 0,
            maxRetries: 3,
        });

        const prompt = `Act as a query analyzer. Categorize the following question text into one of these primary categories: Mathematics, Physics, Chemistry, Biology, Computer Science, or Other.  
If the question belongs to a subdomain (e.g., Calculus, Linear Algebra with Mathematics; Computer Science with Operating Systems, Networks , classify it under the broader category along with the subdomain. 
Only respond with the category name and also tell me which teacher subject this question belongs to. format should be "Computer Science : Operating System : Networks" or "Mathematics : Calculus ".
Here is the text: ${text}`;

        const aiMsg = await llm.invoke([
            {
                role: "system",
                content: "You are a helpful assistant that categorizes academic questions into their main subject domains."
            },
            { role: "user", content: prompt }
        ]);

        return aiMsg.content.trim();
    } catch (error) {
        console.error("Error getting category from Groq:", error);
        return "Other";
    }
}

async function getCategoryFromGemini(text) {
    try {
        // Fall back to Gemini if Groq fails
        const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
        const model = genAI.getGenerativeModel({ model: "gemini-1.5-pro" });

        const prompt = `Act as a query analyzer. Categorize the following question text into one of these primary categories: Mathematics, Physics, Chemistry, Biology, Computer Science, or Other.  
        If the question belongs to a subdomain (e.g.,chemistry with Physical chemistry or chemistry with Organic chemistry  ,Calculus, Linear Algebra with Mathematics; Computer Science with Operating Systems, Networks , classify it under the broader category along with the subdomain. 
        Only respond with the category name and also tell me which teacher subject this question belongs to.
        !important: format should be "Computer Science : Operating System : Networks" or "Mathematics : Calculus ".
        Here is the text: ${text}`;

        const result = await model.generateContent(prompt);

        const category = result.response.text().trim();

        return category;
    } catch (error) {
        console.error("Error getting category from AI models:", error);
        return "Other";
    }
}

function parseCategoryText(text) {
    
    const categories = text.split(", ").map(entry => {
        const [field, subcategory] = entry.split(" : ");
        return { Field: field.trim(), Subcategory: subcategory.trim() };
    });

    return { Category: categories };
}
async function uploadFile(req, res) {
    try {
        if (!req.file) {
            return res.status(400).json({ error: "Please upload a file" });
        }

        const fileUrl = `${req.protocol}://${req.get("host")}/uploads/${req.file.filename}`;
        const { data: { text } } = await Tesseract.recognize(req.file.path, "eng");

        // let category = await getCategoryFromGemini(text);
        let category = await getCategoryFromGroq(text);
        if (category !== "Other") {
            category = parseCategoryText(category);
        } else {
            category = { Category: [{ Field: "Other", Subcategory: "Other" }] };
        }

        const subject = category.Category[0].Field;
        const subcategory = category.Category[0].Subcategory;

        // console.log("Find teacher for:", subject, subcategory);
        // **Create a new Doubt record**
        const doubt = new Doubt({
            student: req.userId,
            imageId: uuidv4(),
            name: req.file.originalname,
            image: fileUrl,
            topics: [subject, subcategory],
            status: "pending"
        });

        await doubt.save();
        // console.log("Doubt Created:", doubt);

        // **Notify the assigned teacher in real-time**
        // if (assignedTeacher) {
        //     io.to(assignedTeacher.toString()).emit("new_doubt", {
        //         message: "A new doubt has been assigned to you",
        //         doubtId: doubt._id
        //     });
        // }

        res.status(200).json({
            message: "File uploaded successfully",
            doubtId: doubt._id,
            file: {
                filename: req.file.filename,
                originalName: req.file.originalname,
                fileUrl: fileUrl,
                size: req.file.size,
                mimeType: req.file.mimetype,
                extractedText: text,
                topics: [subject, subcategory]
            },
            assignedTeacher: null
        });

    } catch (error) {
        console.error("Error uploading image:", error);
        res.status(500).json({ error: "Internal server error" });
    }
}


module.exports = {
    storestatics,
    getstatistics,
    uploadFile,
    upload
};